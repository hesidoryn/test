/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module "react-loadable" {
  /*

    P = Props
    E = Exports

  */

  declare type LoadableExport$LoadingComponentProps = {
    isLoading: boolean,
    pastDelay: boolean,
    timedOut: boolean,
    error: any
  }

  declare type LoadableExport$Options<P, E> = LoadableExport$OptionsWithoutRender<P> | LoadableExport$OptionsWithRender<P, E>;

  declare type LoadableExport$CommonOptions = {

    /**
     * React component displayed after delay until loader() succeeds. Also responsible for displaying errors.
     * 
    If you don't want to render anything you can pass a function that returns null
    (this is considered a valid React component).
    */
    loading: React$ComponentType<LoadableExport$LoadingComponentProps>| (() => null),

    /**
     * Defaults to 200, in milliseconds.
     * 
    Only show the loading component if the loader() has taken this long to succeed or error.
    */
    delay?: number | false | null,

    /**
     * Disabled by default.
     * 
    After the specified time in milliseconds passes, the component's `timedOut` prop will be set to true.
    */
    timeout?: number | false | null,

    /**
     * Optional array of module paths that `Loadable.Capture`'s `report` function will be applied on during
     * server-side rendering. This helps the server know which modules were imported/used during SSR.
    ```ts
    Loadable({
      loader: () => import('./my-component'),
      modules: ['./my-component'],
    });
    ```
    */
    modules?: string[],

    /**
     * An optional function which returns an array of Webpack module ids which you can get
     * with require.resolveWeak. This is used by the client (inside `Loadable.preloadReady`) to
    guarantee each webpack module is preloaded before the first client render.
    ```ts
    Loadable({
      loader: () => import('./Foo'),
      webpack: () => [require.resolveWeak('./Foo')],
    });
    ```
    */
    webpack?: () => number[]
  }

  declare type LoadableExport$OptionsWithoutRender<P> = {

    /**
     * Function returning a promise which returns a React component displayed on success.
     * Resulting React component receives all the props passed to the generated component.
     */
    loader(): Promise<React$ComponentType<P> | {
        default: React$ComponentType<P>
    }>,

    ...$Exact<LoadableExport$CommonOptions>,
  };


  declare type LoadableExport$OptionsWithRender<P, E> = {

    /**
     * Function returning a promise which returns an object to be passed to `render` on success.
     */
    loader(): Promise<E>,

    /**
     * If you want to customize what gets rendered from your loader you can also pass `render`.
     * 
    Note: If you want to load multiple resources at once, you can also use `Loadable.Map`.

    ```ts
    Loadable({
        // ...
        render(loaded, props) {
            const Component = loaded.default;
            return <Component {...props} />
        }
    });
    ```
    */
    render(loaded: E, props: P): React$Node,

    ...$Exact<LoadableExport$CommonOptions>,
  };


  declare type LoadableExport$OptionsWithMap<P, E> = {

    /**
     * An object containing functions which return promises, which resolve to an object to be passed to `render` on success.
     */
    loader: mixed,

    /**
     * If you want to customize what gets rendered from your loader you can also pass `render`.
     * 
    Note: If you want to load multiple resources at once, you can also use `Loadable.Map`.

    ```ts
    Loadable({
        // ...
        render(loaded, props) {
            const Component = loaded.default;
            return <Component {...props} />
        }
    });
    ```
    */
    render(loaded: E, props: P): React$Node,

    ...$Exact<LoadableExport$CommonOptions>,
  };


  declare type LoadableExport$LoadableComponent = {

    /**
     * The generated component has a static method preload() for calling the loader function ahead of time.
     * This is useful for scenarios where you think the user might do something next and want to load the
    next component eagerly.

    Note: preload() intentionally does not return a promise. You should not be depending on the timing of
    preload(). It's meant as a performance optimization, not for creating UI logic.
    */
    preload(): void
  }

  declare type LoadableExport$LoadableCaptureProps = {

    /**
     * Function called for every moduleName that is rendered via React Loadable.
     */
    report: (moduleName: string) => void
  }

  // declare type LoadableExport$Result<P> = React$ComponentType<P> & LoadableExport$LoadableComponent;
  declare type LoadableExport$Result<P> = React$ComponentType<P>;
  

  declare module.exports: {
    <P, E>(
      options: LoadableExport$Options<P, E>
    ): LoadableExport$Result<P>
  };
}
